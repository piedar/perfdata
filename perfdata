#!/usr/bin/env python3
# SPDX-License-Identifier: AGPL-3.0-only

import os
from pathlib import Path
import shutil
import signal
import subprocess as sub
import sys

SCRIPT_DIR = Path(__file__).resolve().parent

def debug(*args):
	print(*args, file=sys.stderr)

def _raise(ex): raise ex

def is_truthy(val):
	return val and val.casefold() == 'true'.casefold() or val == '1'

def get_profile_dir_default(name):
	XDG_CACHE_HOME = Path(os.environ.get('XDG_CACHE_HOME') or Path(os.environ['HOME']) / '.cache')
	return XDG_CACHE_HOME / 'perfdata' / name

def get_profile_dir(name):
	return Path(os.environ.get('PERFDATA_PROFILE_DIR') or get_profile_dir_default(name))


# todo: cleanup

# perf notes
	# todo: does --event=br_inst_retired.all_branches gather enough data?
	# in this example - https://groups.google.com/g/llvm-dev/c/-Ao1uXCi8QM
	# they filter on --event=br_inst_retired.near_taken which doesn't produce anything useful for me

	# --call-graph=fp requires the source to be built with '-fno-omit-frame-pointer'
	# if llvm-profgen gains support in the future we could use '--call-graph=dwarf'

	# --freq=max gathers more events but adds significant cpu overhead when including call-graph
	# todo: maybe if perf-script and llvm-profgen were more optimized...


PERF_BRANCH_FILTER = '--branch-filter=any,u'
PERF_RECORD_PARAMS = [
	PERF_BRANCH_FILTER,
	'--mmap-flush=128K',
	'--call-graph=fp',
	'--event=br_inst_retired.all_branches:uP',
]


perf_exe = shutil.which('perf')


def attach_prof(pids, output_path, binaries):
	prof_output = Path(f"{output_path}.prof")
	prof_output_part = Path(f"{prof_output}.part")
	prof_output.parent.mkdir(parents=True, exist_ok=True)

	perf2prof_exe = SCRIPT_DIR / 'perf2prof'

	# perf output pipes straight to perf2prof
	pid_arg = f"--pid={str.join(',', [str(pid) for pid in pids])}"
	perf_proc = sub.Popen([ perf_exe, 'record', *PERF_RECORD_PARAMS, '--output=-', pid_arg ],
		stdout=sub.PIPE, stderr=sys.stderr,
	)
	try:
		binary_args = [b for b in binaries for b in ['--binary', str(b)]]
		perf2prof_proc = sub.Popen([ str(perf2prof_exe), '-', *binary_args, '--output', str(prof_output_part) ],
			# using another process group to prevent the shell sending SIGINT directly to the worker
			preexec_fn=os.setpgrp,
			# todo: python 3.11 has some interesting properties like
			#start_new_session=True,
			stdin=perf_proc.stdout, stdout=sys.stderr, stderr=sys.stderr,
		)
		perf_proc.stdout.close() # perf2prof now owns this pipe - perf should get SIGPIPE if it closes early

		class AttachedProf:
			def wait(self):
				try:
					perf2prof_proc.communicate()
					if perf2prof_proc.returncode == 0:
						prof_output_part.rename(prof_output)
						debug(f"finished {prof_output}")
					else:
						debug('perf2prof failed - stop recording')
					return perf2prof_proc.returncode
				finally:
					perf_proc.terminate()
		return AttachedProf()

	except:
		perf_proc.terminate()
		raise


def collect_prof(command, output_path, exe_path, binaries):
	# this is the main user process - it gets priority on stdin and stdout
	command_proc = sub.Popen([ str(exe_path), *command[1:] ],
		stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
	)
	try:
		def handler(signum, frame):
			signame = signal.strsignal(signum)
			debug(f"shutting down on {signame}")
			command_proc.terminate()
			# now perf-record finishes and closes pipe, then perf2prof finishes

		signal.signal(signal.SIGINT, handler)
		signal.signal(signal.SIGTERM, handler)
		signal.signal(signal.SIGQUIT, handler)

		attached = attach_prof([command_proc.pid], output_path, binaries)
		attached.wait()
	finally:
		command_proc.wait()

def collect_perfdata(command, output_path):
	output_path.mkdir(parents=True, exist_ok=True)

	# compression uses extra cpu time - much more at higher levels
	# compression levels >= 10 cause lost samples on my system
	# compression has diminishing returns after about level 8

	# todo: might rely on EXE_CACHE instead of buildid

	# with --switch-output there are 1 or more files named like ${PERFDATA_OUTPUT}.{timestamp}
	# --switch-output cannot be read by perf-script when compressed?

	flock_exe = shutil.which('flock')

	perf_proc = sub.Popen([
		flock_exe, '--exclusive', '--timeout', '10', '--no-fork', str(output_path),
		perf_exe, 'record', *PERF_RECORD_PARAMS,
		'--switch-output=1G', '--no-no-buildid',
		'--output', str(output_path / 'perfdata'), '--', *command ], stdout=sys.stdout, stderr=sys.stderr)
	# todo: necessary?
	#chmod -R ug+rX "${output_path}"
	#os.chmod()

def setup_output_path(exe_path):
	# todo: necessary?
	os.umask(0o0027)

	def stamp_default():
		import hashlib
		try:
			with open(exe_path, 'rb') as f:
				return hashlib.file_digest(f, 'sha256').hexdigest()
		except FileNotFoundError:
			return hashlib.sha256(str(exe_path).encode()).hexdigest()

	import time

	PERFDATA_STAMP = os.environ.get('PERFDATA_STAMP') or stamp_default()
	PERFDATA_ID = f"{PERFDATA_STAMP}-{round(time.time())}-{os.getpid()}"
	profile_dir = get_profile_dir(exe_path.resolve().name)
	return profile_dir / f"{PERFDATA_ID}.perfdata"


def main_collect(args):
	command = args.command[1:] if args.command[0] == '--' else args.command
	exe_path = Path(shutil.which(command[0]) or Path(command[0]).resolve()).absolute()
	exe_path.is_file() or _raise(Exception(f"{exe_path} not found (is it a shell builtin?)"))
	output_path = setup_output_path(exe_path)
	if args.format == 'perfdata':
		collect_perfdata(command, output_path)
	elif args.format == 'prof':
		collect_prof(command, output_path, exe_path, args.binary or [exe_path])
	else:
		raise Exception(f"unknown format {args.format}")


def get_matching_pids(exe_path, on_error=debug):
	proc = Path('/proc')
	pids = []
	for p in proc.iterdir():
		try:
			if p.is_dir():
				pexe = (p / 'exe').resolve()
				if len(exe_path.parts) > 1 or exe_path.exists():
					if pexe.exists() and exe_path.samefile(pexe):
						pids.append(int(p.name))
				else:
					if exe_path.name == pexe.name:
						pids.append(int(p.name))
		except PermissionError as error:
			on_error(error)
	return pids

def main_attach(args):
	if args.pid:
		exe_path = Path('/proc', str(args.pid), 'exe').resolve()
		pids = [args.pid]
	elif args.name:
		exe_path = Path(args.name)
		pids = get_matching_pids(exe_path)
	else:
		raise Exception('no --name or --pid specified')

	output_path = setup_output_path(exe_path)

	debug('pids', pids, output_path)

	if args.format == 'perfdata':
		raise Exception('todo: --format=perfdata not yet supported')
	elif args.format == 'prof':
		binaries = args.binary or ([exe_path] if exe_path.exists() else _raise(Exception(f"{exe_path} not found")))
		attach_prof(pids, output_path, binaries).wait()
	else:
		raise Exception(f"unknown format {args.format}")



if __name__ == '__main__':
	import argparse

	cli = argparse.ArgumentParser(allow_abbrev=False)

	cli.add_argument('--format', choices=['perfdata', 'prof'],  default='prof')
	cli.add_argument('--binary', action='append')

	attach_group = cli.add_argument_group('attach')
	#attach_group.add_argument('--wait', action='store_true')
	pgroup = attach_group.add_mutually_exclusive_group()
	pgroup.add_argument('--pid', type=int)
	pgroup.add_argument('--name')

	cli.add_argument('command', nargs=argparse.REMAINDER)

	args = cli.parse_args()

	if args.pid or args.name:
		assert(not args.command)
		main_attach(args)
	elif args.command:
		assert(not args.pid and not args.name)
		main_collect(args)
	else:
		cli.print_help()
