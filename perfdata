#!/usr/bin/env python3
# SPDX-License-Identifier: AGPL-3.0-only

import os
import shutil
import signal
import subprocess as sub
import sys

SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))

def debug(*args):
	print(*args, file=sys.stderr)

def _raise(ex): raise ex

def is_truthy(val):
	return val and val.casefold() == 'true'.casefold() or val == '1'

def get_profile_dir_default(name):
	XDG_CACHE_HOME = os.environ.get('XDG_CACHE_HOME') or os.path.join(os.environ['HOME'], '.cache')
	return os.path.join(XDG_CACHE_HOME, 'perfdata', name)

def get_profile_dir(name):
	return os.environ.get('PERFDATA_PROFILE_DIR') or get_profile_dir_default(name)


# todo: cleanup

# perf notes
	# todo: does --event=br_inst_retired.all_branches gather enough data?
	# in this example - https://groups.google.com/g/llvm-dev/c/-Ao1uXCi8QM
	# they filter on --event=br_inst_retired.near_taken which doesn't produce anything useful for me

	# --call-graph=fp requires the source to be built with '-fno-omit-frame-pointer'
	# if llvm-profgen gains support in the future we could use '--call-graph=dwarf'

	# --freq=max gathers more events but adds significant cpu overhead when including call-graph
	# todo: maybe if perf-script and llvm-profgen were more optimized...


PERF_BRANCH_FILTER = '--branch-filter=any,u'
PERF_RECORD_PARAMS = [
	PERF_BRANCH_FILTER,
	'--mmap-flush=128K',
	'--call-graph=fp',
	'--event=br_inst_retired.all_branches:uP',
]


perf_exe = shutil.which('perf')

def collect_prof(command, output_path, command_exe, binaries):
	PROF_OUTPUT = f"{output_path}.prof"
	PROF_OUTPUT_PART = f"{PROF_OUTPUT}.part"
	os.makedirs(os.path.dirname(PROF_OUTPUT), exist_ok=True)

	perf2prof_exe = os.path.join(SCRIPT_DIR, 'perf2prof')

	# this is the main user process - it gets priority on stdin and stdout
	command_proc = sub.Popen([ command_exe, *command[1:] ], stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
	try:
		def handler(signum, frame):
			signame = signal.strsignal(signum)
			debug(f"shutting down on {signame}")
			command_proc.terminate()
			# now perf-record finishes and closes pipe, then perf2prof finishes

		signal.signal(signal.SIGINT, handler)
		signal.signal(signal.SIGTERM, handler)
		signal.signal(signal.SIGQUIT, handler)

		# perf output pipes straight to perf2prof
		perf_proc = sub.Popen([ perf_exe, 'record', *PERF_RECORD_PARAMS, '--output=-', f"--pid={command_proc.pid}" ], stdout=sub.PIPE, stderr=sys.stderr)
		try:
			binary_args = [b for b in binaries for b in ['--binary', b]]
			perf2prof_proc = sub.Popen([ perf2prof_exe, '-', *binary_args, '--output', PROF_OUTPUT_PART ],
				preexec_fn=os.setpgrp,
				#start_new_session=True,
				stdin=perf_proc.stdout, stdout=sys.stderr, stderr=sys.stderr)
			perf_proc.stdout.close() # perf2prof now owns this pipe - perf should get SIGPIPE if it closes early

			perf2prof_proc.communicate()
			if perf2prof_proc.returncode == 0:
				os.rename(PROF_OUTPUT_PART, PROF_OUTPUT)
				debug(f"finished {PROF_OUTPUT}")
			else:
				debug('perf2prof failed - stop recording')
				perf_proc.terminate()
		finally:
			perf_proc.wait()
	finally:
		command_proc.wait()

def collect_perfdata(command, output_path):
	os.makedirs(output_path, exist_ok=True)

	# compression uses extra cpu time - much more at higher levels
	# compression levels >= 10 cause lost samples on my system
	# compression has diminishing returns after about level 8

	# todo: might rely on EXE_CACHE instead of buildid

	# with --switch-output there are 1 or more files named like ${PERFDATA_OUTPUT}.{timestamp}
	# --switch-output cannot be read by perf-script when compressed?

	flock_exe = shutil.which('flock')

	perf_proc = sub.Popen([
		flock_exe, '--exclusive', '--timeout', '10', '--no-fork', output_path,
		perf_exe, 'record', *PERF_RECORD_PARAMS,
		'--switch-output=1G', '--no-no-buildid',
		f"--output={output_path}/perfdata", '--', *command ], stdout=sys.stdout, stderr=sys.stderr)
	# todo: necessary?
	#chmod -R ug+rX "${output_path}"
	#os.chmod()


def main_collect(args):
	# todo: necessary?
	os.umask(0o0027)
	command = args.command[1:] if args.command[0] == '--' else args.command

	exe_path = shutil.which(command[0]) or os.path.realpath(command[0])
	os.path.isfile(exe_path) or _raise(Exception(f"{exe_path} not found (is it a shell builtin?)"))

	def stamp_default():
		import hashlib
		with open(exe_path, 'rb') as f:
			return hashlib.file_digest(f, 'sha256').hexdigest()

	import time

	PERFDATA_STAMP = os.environ.get('PERFDATA_STAMP') or stamp_default()
	PERFDATA_ID = f"{PERFDATA_STAMP}-{time.time()}-{os.getpid()}"
	profile_dir = get_profile_dir(os.path.basename(os.path.realpath(exe_path)))
	output_path = f"{os.path.join(profile_dir, PERFDATA_ID)}.perfdata"

	if args.format == 'perfdata':
		collect_perfdata(command, output_path)
	else:
		collect_prof(command, output_path, exe_path, args.binary or [exe_path])


def cli_collect(cli):
	cli.add_argument('--format', choices=['perfdata', 'prof'],  default='perfdata')
	cli.add_argument('--binary', action='append')
	cli.add_argument('command', nargs=argparse.REMAINDER)
	cli.set_defaults(func=main_collect)


if __name__ == '__main__':
	import argparse

	cli = argparse.ArgumentParser(allow_abbrev=False)
	cli.set_defaults(func=lambda args: cli.print_help())

	cli_collect(cli)

	args = cli.parse_args()
	args.func(args)
