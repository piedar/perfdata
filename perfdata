#!/bin/bash
# SPDX-License-Identifier: AGPL-3.0-only

function debug() {
	echo >&2 "${0}: ${@}"
}

(return 0 2>/dev/null) && debug "this script cannot be sourced" && return 1

set -e

function die() {
	debug "${@}"
	exit 1
}

function hashsum() {
	sha256sum "${@}" | awk '{ print $1 }'
}

SCRIPT_DIR="$(dirname "$(realpath "${BASH_SOURCE[@]})")")"


COMMAND="${1:?COMMAND not specified}"

EXE_PATH="$(type -p "${COMMAND}" || true)"
if [ -z "${EXE_PATH}" ]; then
	debug "COMMAND ${COMMAND} has no executable path (is it a shell builtin?)"
	exec "${@}"
fi

umask 0027

if [ -z "${PERFDATA_PROFILE_DIR}" ]; then
	EXE_NAME="$(basename "$(realpath "${EXE_PATH}")")"
	: "${PERFDATA_DIR:=${XDG_CACHE_HOME:-${HOME:?}/.cache}/perfdata}"
	: "${PERFDATA_PROFILE:=${EXE_NAME}}"
	PERFDATA_PROFILE_DIR="${PERFDATA_DIR}/${PERFDATA_PROFILE}"
fi
mkdir -p "${PERFDATA_PROFILE_DIR}"

: "${PERFDATA_STAMP:=$(hashsum "${EXE_PATH}")}"
PERFDATA_ID="${PERFDATA_STAMP}-$(date --utc +'%s')-$$"
PERFDATA_JOB_DIR="${PERFDATA_PROFILE_DIR}/${PERFDATA_ID}.perfdata"

# todo: re-enable cleanup
#PERFDATA_PROFILE_DIR="${PERFDATA_PROFILE_DIR}" "${SCRIPT_DIR}/perfdata-cleanup"

# todo: does --event=br_inst_retired.all_branches gather enough data?
# in this example - https://groups.google.com/g/llvm-dev/c/-Ao1uXCi8QM
# they filter on --event=br_inst_retired.near_taken which is probably even less

# --call-graph=fp requires the source to be built with '-fno-omit-frame-pointer'
# if llvm-profgen gains support in the future we could use '--call-graph=dwarf'

PERF_RECORD_PARAMS=(
	--branch-filter=any,u
	--mmap-flush=128K
	--call-graph=fp
	--event=br_inst_retired.all_branches:uP
	--freq=max
)

# the output of llvm-profgen is tiny by comparison
# do the conversion now if so configured
if "${PERFDATA_CONVERT_PROF:-false}"; then
	PROF_OUTPUT="${PERFDATA_JOB_DIR}.prof"
	PROF_OUTPUT_PART="${PROF_OUTPUT}.part"

	exec {p2p_fd}> >(
		set -m # use separate process group so this part doesn't get interrupted
		{
			"${SCRIPT_DIR}/perf2prof" '-' --binary "${EXE_PATH}" --output "${PROF_OUTPUT_PART}" &&
				mv --no-target-directory "${PROF_OUTPUT_PART}" "${PROF_OUTPUT}"
		} || cat >/dev/null # perf2prof failed - ignore remaining input
	)

	# perf can pipe to stdout, but then the command's stdout gets sent to stderr
	# my patched perf can write to a named fifo pipe, keeping the command's pipes intact
	[[ "$(perf record --branch-filter 'any,u' -o >(cat > /dev/null) echo 2>&1)" == *"failed to mmap file"* ]] &&
		PERDATA_HAS_PIPING_PERF=false || PERDATA_HAS_PIPING_PERF=true

	if "${PERDATA_HAS_PIPING_PERF}"; then
		perf record ${PERF_RECORD_PARAMS[@]} \
			--output="/dev/fd/${p2p_fd}" -- "${@}" &
	else
		perf record --branch-filter ${PERF_RECORD_PARAMS[@]} \
			--output='-' -- "${@}" >"/dev/fd/${p2p_fd}" &
	fi
	mainpid=$!

	shutdown_main() {
		debug 'shutting down on signal'
		kill -SIGINT ${mainpid}
	}

	trap shutdown_main SIGINT SIGTERM SIGQUIT
	wait ${mainpid} || debug "${mainpid} ended early - $?"

	# perf-record is already dead so we need to close the pipe before waiting
	debug "finishing ${PROF_OUTPUT} with perf2prof..."
	exec {p2p_fd}>&-
	wait
	exit 0
fi

mkdir -p "${PERFDATA_JOB_DIR}"

# compression uses extra cpu time - much more at higher levels
# compression levels >= 10 cause lost samples on my system
# compression has diminishing returns after about level 8

# todo: might rely on EXE_CACHE instead of buildid

flock --exclusive --timeout 10 --no-fork "${PERFDATA_JOB_DIR}" \
	perf record ${PERF_RECORD_PARAMS[@]} \
	--switch-output=1G --no-no-buildid \
	--output "${PERFDATA_JOB_DIR}/perfdata" -- "${@}"

# with --switch-output there are 1 or more files named like ${PERFDATA_OUTPUT}.{timestamp}
# --switch-output cannot be read by perf-script when compressed?

chmod -R ug+rX "${PERFDATA_JOB_DIR}"
