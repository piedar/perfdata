#!/usr/bin/env python3
# SPDX-License-Identifier: AGPL-3.0-only

import os
import shutil
import signal
import subprocess as sub
import sys

SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))

def debug(*args):
	print(*args, file=sys.stderr)

def _raise(ex): raise ex

def is_truthy(val):
	return val and val.casefold() == 'true'.casefold() or val == '1'

def get_profile_dir_default(name):
	XDG_CACHE_HOME = os.environ.get('XDG_CACHE_HOME') or os.path.join(os.environ['HOME'], '.cache')
	return os.path.join(XDG_CACHE_HOME, 'perfdata', name)

def get_profile_dir(name):
	return os.environ.get('PERFDATA_PROFILE_DIR') or get_profile_dir_default(name)


# todo: cleanup

# perf notes
	# todo: does --event=br_inst_retired.all_branches gather enough data?
	# in this example - https://groups.google.com/g/llvm-dev/c/-Ao1uXCi8QM
	# they filter on --event=br_inst_retired.near_taken which doesn't produce anything useful for me

	# --call-graph=fp requires the source to be built with '-fno-omit-frame-pointer'
	# if llvm-profgen gains support in the future we could use '--call-graph=dwarf'

	# --freq=max gathers more events but adds significant cpu overhead when including call-graph
	# todo: maybe if perf-script and llvm-profgen were more optimized...


PERF_BRANCH_FILTER = '--branch-filter=any,u'
PERF_RECORD_PARAMS = [
	PERF_BRANCH_FILTER,
	'--mmap-flush=128K',
	'--call-graph=fp',
	'--event=br_inst_retired.all_branches:uP',
]


perf_exe = shutil.which('perf')

def collect_prof(command, output_path, binaries):
	PROF_OUTPUT = f"{output_path}.prof"
	PROF_OUTPUT_PART = f"{PROF_OUTPUT}.part"
	os.makedirs(os.path.dirname(PROF_OUTPUT), exist_ok=True)

	perf2prof = os.path.join(SCRIPT_DIR, 'perf2prof')

	# perf can pipe to stdout, but then the command's stdout gets sent to stderr
	# my patched perf can write to a named fifo pipe, keeping the command's pipes intact
	has_piping_perf = 'failed to mmap file' not in sub.run([ perf_exe, PERF_BRANCH_FILTER, '-o', '/dev/stderr' ], stderr=sub.PIPE, text=True).stderr

	if has_piping_perf:
		from contextlib import contextmanager
		@contextmanager
		def TemporaryNamedPipe(name='fifo'):
			"""Context Manager for creating a temporary named pipe (aka fifo)."""
			"""The pipe can still be used anonymously if open() before the context closes."""
			import tempfile
			tmpdir = tempfile.mkdtemp()
			try:
				filename = os.path.join(tmpdir, name)
				os.mkfifo(filename)
				try:
					yield filename
				finally:
					os.unlink(filename)
			finally:
				os.rmdir(tmpdir)


		with TemporaryNamedPipe('perfdata.fifo') as perfdata_fifo:
			producer = sub.Popen([ perf_exe, 'record', *PERF_RECORD_PARAMS, '--output', perfdata_fifo, '--', *command ], stdout=sys.stdout, stderr=sys.stderr)
			producer_output = open(perfdata_fifo, 'rb')
			# the pipe is now open, so deleting its file makes it anonymous
	else:
		producer = sub.Popen([ perf_exe, 'record', *PERF_RECORD_PARAMS, '--output=-', '--', *command ], stdout=sub.PIPE, stderr=sys.stderr)
		producer_output = producer.stdout

	binary_args = [b for b in binaries for b in ['--binary', b]]
	consumer = sub.Popen([ perf2prof, '-', *binary_args, '--output', PROF_OUTPUT_PART ],
		preexec_fn=os.setpgrp,
		#start_new_session=True,
		stdin=producer_output, stdout=sys.stderr, stderr=sys.stderr)

	def handler(signum, frame):
		signame = signal.strsignal(signum)
		debug(f"shutting down on {signame}")
		producer.terminate()

	signal.signal(signal.SIGINT, handler)
	signal.signal(signal.SIGTERM, handler)
	signal.signal(signal.SIGQUIT, handler)

	consumer.communicate()
	if consumer.returncode == 0:
		os.rename(PROF_OUTPUT_PART, PROF_OUTPUT)
		debug(f"finished {PROF_OUTPUT}")
	else:
		# todo: could use `perf record --control=fifo:` to stop recording here
		debug('consumer failed - draining output and continuing')
		def drain(f):
			while f.read(128 * 1024):
				pass
		drain(producer_output)

	producer.wait()

def collect_perfdata(command, output_path):
	os.makedirs(output_path, exist_ok=True)

	# compression uses extra cpu time - much more at higher levels
	# compression levels >= 10 cause lost samples on my system
	# compression has diminishing returns after about level 8

	# todo: might rely on EXE_CACHE instead of buildid

	# with --switch-output there are 1 or more files named like ${PERFDATA_OUTPUT}.{timestamp}
	# --switch-output cannot be read by perf-script when compressed?

	flock_exe = shutil.which('flock')

	perf_proc = sub.Popen([
		flock_exe, '--exclusive', '--timeout', '10', '--no-fork', output_path,
		perf_exe, 'record', *PERF_RECORD_PARAMS,
		'--switch-output=1G', '--no-no-buildid',
		'--output={output_path}/perfdata', '--', *command ], stdout=sys.stdout, stderr=sys.stderr)
	# todo: necessary?
	#chmod -R ug+rX "${output_path}"
	#os.chmod()


def main_collect(args):
	# todo: necessary?
	os.umask(0o0027)
	command = args.command[1:] if args.command[0] == '--' else args.command

	exe_path = shutil.which(command[0]) or os.path.realpath(command[0])
	os.path.isfile(exe_path) or _raise(Exception(f"{exe_path} not found (is it a shell builtin?)"))

	def stamp_default():
		import hashlib
		with open(exe_path, 'rb') as f:
			return hashlib.file_digest(f, 'sha256').hexdigest()

	import time

	PERFDATA_STAMP = os.environ.get('PERFDATA_STAMP') or stamp_default()
	PERFDATA_ID = f"{PERFDATA_STAMP}-{time.time()}-{os.getpid()}"
	profile_dir = get_profile_dir(os.path.basename(os.path.realpath(exe_path)))
	output_path = f"{os.path.join(profile_dir, PERFDATA_ID)}.perfdata"

	if args.format == 'perfdata':
		collect_perfdata(command, output_path)
	else:
		collect_prof(command, output_path, args.binary or [exe_path])


def cli_collect(cli):
	cli.add_argument('--format', choices=['perfdata', 'prof'],  default='perfdata')
	cli.add_argument('--binary', action='append')
	cli.add_argument('command', nargs=argparse.REMAINDER)
	cli.set_defaults(func=main_collect)


if __name__ == '__main__':
	import argparse

	cli = argparse.ArgumentParser(allow_abbrev=False)
	cli.set_defaults(func=lambda args: cli.print_help())

	cli_collect(cli)

	args = cli.parse_args()
	args.func(args)
